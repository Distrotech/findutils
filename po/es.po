# Mensajes en español para GNU findutils.
# Copyright (C) 1996, 2001, 2004 Free Software Foundation, Inc.
# Iñaky Pérez González <inaky@peloncho.fis.ucm.es>, 1996.
# Santiago Vila Doncel <sanvila@unex.es>, 2001, 2004.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU findutils 4.2.6\n"
"Report-Msgid-Bugs-To: bug-findutils@gnu.org\n"
"POT-Creation-Date: 2007-12-08 14:17+0000\n"
"PO-Revision-Date: 2004-12-23 16:57+0100\n"
"Last-Translator: Santiago Vila Doncel <sanvila@unex.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: gnulib/lib/argmatch.c:133
#, c-format
msgid "invalid argument %s for %s"
msgstr "argumento %s inválido para %s"

#: gnulib/lib/argmatch.c:134
#, c-format
msgid "ambiguous argument %s for %s"
msgstr "argumento %s ambiguo para %s"

#: gnulib/lib/argmatch.c:153
#, c-format
msgid "Valid arguments are:"
msgstr "Los argumentos válidos son:"

#: gnulib/lib/closeout.c:73
msgid "write error"
msgstr ""

#: gnulib/lib/error.c:125
msgid "Unknown system error"
msgstr "Error del sistema desconocido"

#: gnulib/lib/getopt.c:530 gnulib/lib/getopt.c:546
#, c-format
msgid "%s: option `%s' is ambiguous\n"
msgstr "%s: la opción `%s' es ambigua\n"

#: gnulib/lib/getopt.c:579 gnulib/lib/getopt.c:583
#, c-format
msgid "%s: option `--%s' doesn't allow an argument\n"
msgstr "%s: la opción `--%s' no admite ningún argumento\n"

#: gnulib/lib/getopt.c:592 gnulib/lib/getopt.c:597
#, c-format
msgid "%s: option `%c%s' doesn't allow an argument\n"
msgstr "%s: la opción `%c%s' no admite ningún argumento\n"

#: gnulib/lib/getopt.c:640 gnulib/lib/getopt.c:659 gnulib/lib/getopt.c:975
#: gnulib/lib/getopt.c:994
#, c-format
msgid "%s: option `%s' requires an argument\n"
msgstr "%s: la opción `%s' necesita un argumento\n"

#: gnulib/lib/getopt.c:697 gnulib/lib/getopt.c:700
#, c-format
msgid "%s: unrecognized option `--%s'\n"
msgstr "%s: opción no reconocida `--%s'\n"

#: gnulib/lib/getopt.c:708 gnulib/lib/getopt.c:711
#, c-format
msgid "%s: unrecognized option `%c%s'\n"
msgstr "%s: opción no reconocida `%c%s'\n"

#: gnulib/lib/getopt.c:763 gnulib/lib/getopt.c:766
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción ilegal -- %c\n"

#: gnulib/lib/getopt.c:772 gnulib/lib/getopt.c:775
#, c-format
msgid "%s: invalid option -- %c\n"
msgstr "%s: opción inválida -- %c\n"

#: gnulib/lib/getopt.c:827 gnulib/lib/getopt.c:843 gnulib/lib/getopt.c:1047
#: gnulib/lib/getopt.c:1065
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción necesita un argumento -- %c\n"

#: gnulib/lib/getopt.c:896 gnulib/lib/getopt.c:912
#, c-format
msgid "%s: option `-W %s' is ambiguous\n"
msgstr "%s: la opción `-W %s' es ambigua\n"

#: gnulib/lib/getopt.c:936 gnulib/lib/getopt.c:954
#, c-format
msgid "%s: option `-W %s' doesn't allow an argument\n"
msgstr "%s: la opción `-W %s' no admite ningún argumento\n"

# No ha habido ninguna queja en coreutils, pongamos aquí también los
# símbolos de cita tradicionales en español.
#. TRANSLATORS:
#. Get translations for open and closing quotation marks.
#.
#. The message catalog should translate "`" to a left
#. quotation mark suitable for the locale, and similarly for
#. "'".  If the catalog has no translation,
#. locale_quoting_style quotes `like this', and
#. clocale_quoting_style quotes "like this".
#.
#. For example, an American English Unicode locale should
#. translate "`" to U+201C (LEFT DOUBLE QUOTATION MARK), and
#. should translate "'" to U+201D (RIGHT DOUBLE QUOTATION
#. MARK).  A British English Unicode locale should instead
#. translate these to U+2018 (LEFT SINGLE QUOTATION MARK) and
#. U+2019 (RIGHT SINGLE QUOTATION MARK), respectively.
#.
#. If you don't know what to put here, please see
#. <http://en.wikipedia.org/wiki/Quotation_mark#Glyphs>
#. and use glyphs suitable for your language.
#: gnulib/lib/quotearg.c:228
msgid "`"
msgstr "«"

#: gnulib/lib/quotearg.c:229
msgid "'"
msgstr "»"

#: gnulib/lib/rpmatch.c:69
msgid "^[yY]"
msgstr "^[sS]"

#: gnulib/lib/rpmatch.c:72
msgid "^[nN]"
msgstr "^[nN]"

#: gnulib/lib/xalloc-die.c:34
#, fuzzy
msgid "memory exhausted"
msgstr "Memoria agotada"

#: gnulib/lib/xstrtol-error.c:63
#, fuzzy, c-format
msgid "invalid %s%s argument `%s'"
msgstr "argumento `%s' inválido para la opción `%s'"

#: gnulib/lib/xstrtol-error.c:68
#, fuzzy, c-format
msgid "invalid suffix in %s%s argument `%s'"
msgstr "argumento `%s' inválido para la opción `%s'"

#: gnulib/lib/xstrtol-error.c:72
#, fuzzy, c-format
msgid "%s%s argument `%s' too large"
msgstr "lista de argumentos demasiado larga"

#: find/find.c:455
msgid ""
"The environment variable FIND_BLOCK_SIZE is not supported, the only thing "
"that affects the block size is the POSIXLY_CORRECT environment variable"
msgstr ""
"La variable de entorno FIND_BLOCK_SIZE no está soportada, lo único que\n"
"afecta al tamaño del bloque es la variable de entorno POSIXLY_CORRECT"

#: find/find.c:537
msgid "paths must precede expression"
msgstr "Las rutas-de-acceso deben preceder la expresión"

#: find/find.c:543
#, c-format
msgid "invalid predicate `%s'"
msgstr "predicado inválido `%s'"

#: find/find.c:551
#, c-format
msgid "missing argument to `%s'"
msgstr "falta el argumento de `%s'"

#: find/find.c:553
#, c-format
msgid "invalid argument `%s' to `%s'"
msgstr "argumento `%s' inválido para la opción `%s'"

#: find/find.c:609
msgid "unexpected extra predicate"
msgstr "predicado extra inesperado"

#: find/find.c:661 find/find.c:664
msgid "cannot get current directory"
msgstr "no se puede obtener el directorio actual"

#: find/find.c:836
#, fuzzy, c-format
msgid "Warning: filesystem %s has recently been unmounted."
msgstr "El sistema de ficheros %s ha sido desmontado recientemente."

#: find/find.c:846
#, fuzzy, c-format
msgid "Warning: filesystem %s has recently been mounted."
msgstr "El sistema de ficheros %s ha sido montado recientemente."

#: find/find.c:941
#, c-format
msgid ""
"%s%s changed during execution of %s (old device number %ld, new device "
"number %ld, filesystem type is %s) [ref %ld]"
msgstr ""
"%s%s ha cambiado durante la ejecución de %s (número de dispositivo antiguo %"
"ld,\n"
"número de dispositivo nuevo %ld, el tipo de sistema de ficheros es %s [ref %"
"ld]"

#: find/find.c:978
#, c-format
msgid ""
"%s%s changed during execution of %s (old inode number %ld, new inode number %"
"ld, filesystem type is %s) [ref %ld]"
msgstr ""
"%s%s ha cambiado durante la ejecución de %s (número de nodo-i antiguo %ld,\n"
"número de nodo-i nuevo %ld, tipo de sistema de ficheros %s) [ref %ld]"

#: find/find.c:1536
#, c-format
msgid ""
"Symbolic link `%s' is part of a loop in the directory hierarchy; we have "
"already visited the directory to which it points."
msgstr ""

#: find/find.c:1551
#, c-format
msgid ""
"Filesystem loop detected; `%s' has the same device number and inode as a "
"directory which is %d %s."
msgstr ""

#: find/find.c:1555
msgid "level higher in the filesystem hierarchy"
msgstr ""

#: find/find.c:1556
msgid "levels higher in the filesystem hierarchy"
msgstr ""

#: find/find.c:1926
#, c-format
msgid "warning: not following the symbolic link %s"
msgstr ""

#: find/find.c:1970
#, c-format
msgid ""
"WARNING: Hard link count is wrong for %s: this may be a bug in your "
"filesystem driver.  Automatically turning on find's -noleaf option.  Earlier "
"results may have failed to include directories that should have been "
"searched."
msgstr ""

#: find/fstype.c:249
msgid "unknown"
msgstr "desconocido"

#: find/parser.c:371
#, c-format
msgid ""
"warning: you have specified the %s option after a non-option argument %s, "
"but options are not positional (%s affects tests specified before it as well "
"as those specified after it).  Please specify options before other "
"arguments.\n"
msgstr ""
"atención: ha especificado la opción %s después de un argumento %s que no\n"
"es una opción, pero las opciones no son de posición (%s afecta tanto a\n"
"las evaluaciones especificadas antes de él como a las especificadas\n"
"después). Por favor especifique las opciones antes de otros argumentos.\n"

#: find/parser.c:610
msgid ""
"warning: the -d option is deprecated; please use -depth instead, because the "
"latter is a POSIX-compliant feature."
msgstr ""
"atención: la opción -d está obsoleta; por favor utilice -depth en su lugar,\n"
"ya que se trata de una característica que cumple con POSIX."

#  ¿Cómo traducir "path"? Me inclino por ahora por camino, pero quizá sería
#  más mejor que bueno poner directorio o algo así. IPG
#  ¡Olé! Gracias a tos los de es@li.org que me habeis dado "ruta de acceso".
#  No se qué significado tendría mi vida sin vuestra ayuda ;), snif ... :~)
#  IPG
#: find/parser.c:780
#, c-format
msgid "Usage: %s [path...] [expression]\n"
msgstr "Modo de empleo: %s [ruta-de-acceso...] [expresión]\n"

# sugerencia: si no se dan -> si no hay otros. sv
#
# No, aquí creo que no vale, ya que es "si no das operadores", esto
# es, si no das ninguno, no que no haya otros. Se refiere al caso
# de que no se dé un operador entre dos `sentencias' (además claro
# de que sólo se puede dar uno).
#
# Bueno, el plural ("others") del original tiene un sentido "respectivo",
# Quiere decir que si en cada sitio donde puedes poner un operador o no
# ponerlo, no pones uno que sea distinto de -and, se supone -and.
# Obviamente para poner otro que no sea -and tienes que poner alguno...
# La única diferencia, yo creo, es que según el original, si pones -and,
# no le hace caso, y toma el operador por defecto, que vuelve a ser -and
# ¡Mira que son retorcidos! :-) sv
#
# Bueno, déjalo así si quieres, pero fíjate en lo soso que queda el "dan",
# queda a mil kilómetros de la palabra "operadores" (me refiero a lo lejos
# que están el verbo y el objeto directo, me suena un poco rarillo).
# Parece que es "si no se dan de tortas". sv
#
# Sugerencia: "se supone -and si no se da ningún operador"
# o mejor "si no se da ninguno". sv
#
# Lo dejo así. ipg
#: find/parser.c:782
#, fuzzy
msgid ""
"\n"
"default path is the current directory; default expression is -print\n"
"expression may consist of: operators, options, tests, and actions:\n"
msgstr ""
"la ruta de acceso por defecto es el directorio actual; la expresión por\n"
"defecto es -print\n"
"la expresión puede ser:\n"
"operadores (prioridad decreciente; se supone -and si no se dan):\n"
"      ( EXPR ) ! EXPR -not EXPR EXPR1 -a EXPR2 EXPR1 -and EXPR2"

# sugerencia: si no se dan -> si no hay otros. sv
#
# No, aquí creo que no vale, ya que es "si no das operadores", esto
# es, si no das ninguno, no que no haya otros. Se refiere al caso
# de que no se dé un operador entre dos `sentencias' (además claro
# de que sólo se puede dar uno).
#
# Bueno, el plural ("others") del original tiene un sentido "respectivo",
# Quiere decir que si en cada sitio donde puedes poner un operador o no
# ponerlo, no pones uno que sea distinto de -and, se supone -and.
# Obviamente para poner otro que no sea -and tienes que poner alguno...
# La única diferencia, yo creo, es que según el original, si pones -and,
# no le hace caso, y toma el operador por defecto, que vuelve a ser -and
# ¡Mira que son retorcidos! :-) sv
#
# Bueno, déjalo así si quieres, pero fíjate en lo soso que queda el "dan",
# queda a mil kilómetros de la palabra "operadores" (me refiero a lo lejos
# que están el verbo y el objeto directo, me suena un poco rarillo).
# Parece que es "si no se dan de tortas". sv
#
# Sugerencia: "se supone -and si no se da ningún operador"
# o mejor "si no se da ninguno". sv
#
# Lo dejo así. ipg
#: find/parser.c:785
#, fuzzy
msgid ""
"operators (decreasing precedence; -and is implicit where no others are "
"given):\n"
"      ( EXPR )   ! EXPR   -not EXPR   EXPR1 -a EXPR2   EXPR1 -and EXPR2\n"
"      EXPR1 -o EXPR2   EXPR1 -or EXPR2   EXPR1 , EXPR2\n"
msgstr ""
"la ruta de acceso por defecto es el directorio actual; la expresión por\n"
"defecto es -print\n"
"la expresión puede ser:\n"
"operadores (prioridad decreciente; se supone -and si no se dan):\n"
"      ( EXPR ) ! EXPR -not EXPR EXPR1 -a EXPR2 EXPR1 -and EXPR2"

#: find/parser.c:789
#, fuzzy
msgid ""
"positional options (always true): -daystart -follow -regextype\n"
"\n"
"normal options (always true, specified before other expressions):\n"
"      -depth --help -maxdepth LEVELS -mindepth LEVELS -mount -noleaf\n"
"      --version -xdev -ignore_readdir_race -noignore_readdir_race\n"
msgstr ""
"      EXPR1 -o EXPR2 EXPR1 -or EXPR2 EXPR1 , EXPR2\n"
"opciones de posición (siempre verdaderas): -daystart -follow\n"
"opciones normales (siempre verdaderas, se ponen después de otras "
"expresiones):\n"
"        -depth --help -maxdepth NIVELES -mindepth NIVELES -mount -noleaf\n"
"        --version -xdev -ignore_readdir_race -noignore_readdir_race\n"
"evaluaciones (N puede ser +N, -N o N): -amin N -anewer FICHERO -atime N\n"
"                                       -cmin N"

# FIXME: ¿Cómo traducir pattern? Plantilla queda de pena; he dejado EXPR-REG,
#        a ver si cuela. IPG
#        Consulto mi "Libro gordo de Petete metido a hacker" (uséase, mi madre)
#        y dice que ella en todos los libros de UNIX ha visto que se le llama
#        expresión regular, y que le parece el término más adecuado (cosa
#        que a mí también). Me inclino por su experiencia (que para algo es
#        una telekita que lleva desarrollando en UN*X desde que lo inventaron)
#        y usaré esta traducción, hasta que salga una que parezca mejor. IPG
#
#        También me han sugerido `patrón', pero prefiero EXPR-REG. IPG
#
#: find/parser.c:794
#, fuzzy
msgid ""
"tests (N can be +N or -N or N): -amin N -anewer FILE -atime N -cmin N\n"
"      -cnewer FILE -ctime N -empty -false -fstype TYPE -gid N -group NAME\n"
"      -ilname PATTERN -iname PATTERN -inum N -iwholename PATTERN -iregex "
"PATTERN\n"
"      -links N -lname PATTERN -mmin N -mtime N -name PATTERN -newer FILE"
msgstr ""
"      -cnewer FICHERO -ctime N -empty -false -fstype TIPO -gid N\n"
"      -group NOMBRE -ilname EXPR-REG -iname EXPR-REG -inum N\n"
"      -iwholename EXPR-REG -iregex EXPR-REG -links N -lname EXPR-REG\n"
"      -mmin N -mtime N -name EXPR-REG -newer FICHERO"

#: find/parser.c:799
#, fuzzy
msgid ""
"      -nouser -nogroup -path PATTERN -perm [+-]MODE -regex PATTERN\n"
"      -wholename PATTERN -size N[bcwkMG] -true -type [bcdpflsD] -uid N\n"
"      -used N -user NAME -xtype [bcdpfls]\n"
msgstr ""
"      -nouser -nogroup -path EXPR-REG -perm [+-]MODO -regex EXPR-REG\n"
"      -wholename EXPR-REG -size N[bcwkMG] -true -type [bcdpflsD] -uid N\n"
"      -used N -user NOMBRE -xtype [bcdpfls]"

#: find/parser.c:803
msgid ""
"actions: -delete -print0 -printf FORMAT -fprintf FILE FORMAT -print \n"
"      -fprint0 FILE -fprint FILE -ls -fls FILE -prune -quit\n"
"      -exec COMMAND ; -exec COMMAND {} + -ok COMMAND ;\n"
"      -execdir COMMAND ; -execdir COMMAND {} + -okdir COMMAND ;\n"
msgstr ""

#: find/parser.c:809
msgid ""
"Report (and track progress on fixing) bugs via the findutils bug-reporting\n"
"page at http://savannah.gnu.org/ or, if you have no web access, by sending\n"
"email to <bug-findutils@gnu.org>."
msgstr ""
"Informe sobre bichos (y siga el progreso de su corrección) a través de la\n"
"página de comunicación de bichos en http://savannah.gnu.org/ o bien, si no\n"
"tiene acceso a web, enviando un mensaje a <bug-findutils@gnu.org>."

#: find/parser.c:840
msgid "sanity check of the fnmatch() library function failed."
msgstr ""
"la comprobación de adecuación de la función de biblioteca fnmatch() falló."

#: find/parser.c:855
#, c-format
msgid ""
"warning: Unix filenames usually don't contain slashes (though pathnames "
"do).  That means that '%s %s' will probably evaluate to false all the time "
"on this system.  You might find the '-wholename' test more useful, or "
"perhaps '-samefile'.  Alternatively, if you are using GNU grep, you could "
"use 'find ... -print0 | grep -FzZ %s'."
msgstr ""

#: find/parser.c:897
msgid ""
"warning: the predicate -ipath is deprecated; please use -iwholename instead."
msgstr ""
"atención: el predicado -ipath está obsoleto; por favor use -iwholename en\n"
"su lugar"

#: find/parser.c:1337
#, c-format
msgid "invalid mode `%s'"
msgstr "modo inválido `%s'"

#: find/parser.c:1373
#, c-format
msgid ""
"warning: you have specified a mode pattern %s which is equivalent to 000. "
"The meaning of -perm /000 will soon be changed to be consistent with -perm -"
"000; that is, at the moment it matches no files but it will soon be changed "
"to match all files."
msgstr ""

# Nota: No es que no se haya dado el argumento requerido a la opción -size,
# sino que se ha dado un argumento nulo, que es distinto.
# Para ver la sutil diferencia, poner LANG=C y comparar esto:
#
# find . -size
#
# con esto otro:
#
# find . -size ""
#
#: find/parser.c:1526
msgid "invalid null argument to -size"
msgstr "argumento nulo inválido para la opción -size"

#: find/parser.c:1572
#, c-format
msgid "invalid -size type `%c'"
msgstr "tipo dado a -size inválido `%c'"

#: find/parser.c:1690
#, c-format
msgid "GNU find version %s\n"
msgstr "GNU find versión %s\n"

#: find/parser.c:1691 locate/code.c:165 locate/locate.c:1282 xargs/xargs.c:576
#, fuzzy, c-format
msgid "Built using GNU gnulib version %s\n"
msgstr "GNU findutils versión %s\n"

#: find/parser.c:1692
#, c-format
msgid "Features enabled: "
msgstr ""

#: find/parser.c:1939
#, c-format
msgid "warning: unrecognized escape `\\%c'"
msgstr "atención: secuencia de escape `\\%c' no reconocida"

#: find/parser.c:1954
#, c-format
msgid "error: %s at end of format string"
msgstr ""

#: find/parser.c:1990
#, c-format
msgid "warning: unrecognized format directive `%%%c'"
msgstr "atención: directiva de formato `%%%c' no reconocida"

#: find/parser.c:2096
#, c-format
msgid ""
"The current directory is included in the PATH environment variable, which is "
"insecure in combination with the %s action of find.  Please remove the "
"current directory from your $PATH (that is, remove \".\" or leading or "
"trailing colons)"
msgstr ""

#: find/parser.c:2194
msgid ""
"You may not use {} within the utility name for -execdir and -okdir, because "
"this is a potential security problem."
msgstr ""

#: find/parser.c:2217
#, c-format
msgid "Only one instance of {} is supported with -exec%s ... +"
msgstr ""

#: find/parser.c:2230
#, fuzzy
msgid "The environment is too large for exec()."
msgstr "el entorno es demasiado grande para exec"

#: find/pred.c:1178
#, c-format
msgid "< %s ... %s > ? "
msgstr "< %s ... %s > ? "

# FIXME: ¿¿¿??? ¡¡¿¿Y cómo leches traduzco yo esto??!!  IPG
#        Después de que me hayan llamado de todo por intentar traducir
#        una llamada al sistema ;) sigo pensando que este mensaje es
#        más claro e informativo que el original (de hecho, es un
#        pelín más largo y no exige saber tanto UNIX ...) IPG
#
# Esto me parece muy muy muy largo.
# Sugerencia: "No se puede ejecutar fork". sv
# E insisto: Si no eres experto en programación Unix lo mismo te da
# "duplicar un proceso" que "fork".
# De hecho, yo todavía no sé lo que es (ninguna de las dos cosas). sv
#
# ¡¡Otia!! Eso es grave ... fork() es la llamada al sistema que se usa
# para duplicar un programa en dos idénticos, pero con distinto PID.
# Una vez que vuelve, en el padre devuelve el PID del hijo, y en el
# hijo, cero. El hijo entonces lo detecta y una de dos, o sigue, o
# ejecuta otro programa con exec() (que solapa todo el espacio del
# proceso con el del nuevo programa). Prefiero dejar la explicación
# larga, en beneficio de gente como tú :) ipg
#
# Vale, pues ahora te digo:
#
# 1. Nada de lo anterior es evidente con la simple vista de
#    la frase "se duplica el proceso".
# 2. Ahora que ya me lo has explicado, lo mismo me da que me pongas
# exclusivamente lo de fork() a que me pongas la larga parrafada que
# tienes en este momento. sv
#
# ¿Ves por qué no me acaba de gustar? sv
#
# Nota: Jim Meyering tenía en fileutils un mensaje parecido a este, que al
# final conseguimos (Ulises y yo) que lo cambiara por
# msgid "fork system call failed"
#  que yo traduje así:
# msgstr "falló la llamada al sistema `fork'"
# ¿Qué te parece?
#
# Al fin y al cabo es la coletilla que tengo yo al final de mi
# comentario, ¿no? Me parece lo mismo, má o meno, pero por no meternos
# en darle caña y acabar ya esto de una vez :) ...
#: find/pred.c:1580 xargs/xargs.c:1026
msgid "cannot fork"
msgstr "falló la llamada al sistema `fork()'"

#: find/pred.c:1620
#, c-format
msgid "error waiting for %s"
msgstr "error esperando al proceso %s"

#: find/pred.c:1628
#, c-format
msgid "%s terminated by signal %d"
msgstr "%s terminado por la señal %d"

#: find/tree.c:65 find/tree.c:70 find/tree.c:117 find/tree.c:156
msgid "invalid expression"
msgstr "expresión inválida"

#: find/tree.c:74
msgid ""
"invalid expression; you have used a binary operator with nothing before it."
msgstr ""

#: find/tree.c:78
#, fuzzy
msgid "invalid expression; you have too many ')'"
msgstr "expresión inválida"

#: find/tree.c:97
msgid ""
"invalid expression; I was expecting to find a ')' somewhere but did not see "
"one."
msgstr ""

# Creo que la traducción ideal de oops sería ¡huy! sv
# Y si no: ¿A algún español le has visto que diga "oops"?
#
# Si :) Todas las mañanas en el espejo. De todas maneras,
# `¡huy!' creo que no expresa exactamente el `indicar que
# parece que hay un problema' ... yo creo que quedaría
# mejor `oh, oh' (Rainman ... :). ipg
#
# Pero si después del huy te dicen que la expresión no es válida, está
# claro que había un problema...
# Ya, pero puestos, casi podríamos buscar una expresión común para
# los `oops'
# Pon `oh, oh', si crees que es lo apropiado.
# Lo decía más que nada por no dejarlo en inglés siendo el español
# tan rico y variado para las interjecciones.
# (Y me consta que tú sabes bastante de esto :-)
# ¡¡Carajo!! ¿yo?. Voy a dejar `oh, oh', y si a la gente le gusta
# (a mí me parece coñero), lo dejamos, y si no, ponemos `huy'. ipg
# Vale. sv
#
# Aquí también tengo pensado hacer publicidad ;-) sv
#
# Aparte de lo anterior. Si vas a dejar "oh, oh", ¿no sería mejor
# ponerlo sin tantas exclamaciones? (no me pegan)
#
# Ok. ipg
#
# Pero yo decía al revés... (como en el original).
# Lo cambio. sv
# E incluso si te parece, no ponemos ninguna exclamación en ninguno
# de los dos sitios.
# (Donde menos me pegan es en el "oh, oh", parece cosa de Papá Noel...). sv
#
# Será por las fechas ... ;) ok, claudico. ipg
#: find/tree.c:102 find/tree.c:324
msgid "oops -- invalid expression type!"
msgstr "oh, oh -- ¡tipo de expresión inválido!"

# Creo que la traducción ideal de oops sería ¡huy! sv
# Y si no: ¿A algún español le has visto que diga "oops"?
#
# Si :) Todas las mañanas en el espejo. De todas maneras,
# `¡huy!' creo que no expresa exactamente el `indicar que
# parece que hay un problema' ... yo creo que quedaría
# mejor `oh, oh' (Rainman ... :). ipg
#
# Pero si después del huy te dicen que la expresión no es válida, está
# claro que había un problema...
# Ya, pero puestos, casi podríamos buscar una expresión común para
# los `oops'
# Pon `oh, oh', si crees que es lo apropiado.
# Lo decía más que nada por no dejarlo en inglés siendo el español
# tan rico y variado para las interjecciones.
# (Y me consta que tú sabes bastante de esto :-)
# ¡¡Carajo!! ¿yo?. Voy a dejar `oh, oh', y si a la gente le gusta
# (a mí me parece coñero), lo dejamos, y si no, ponemos `huy'. ipg
# Vale. sv
#
# Aquí también tengo pensado hacer publicidad ;-) sv
#
# Aparte de lo anterior. Si vas a dejar "oh, oh", ¿no sería mejor
# ponerlo sin tantas exclamaciones? (no me pegan)
#
# Ok. ipg
#
# Pero yo decía al revés... (como en el original).
# Lo cambio. sv
# E incluso si te parece, no ponemos ninguna exclamación en ninguno
# de los dos sitios.
# (Donde menos me pegan es en el "oh, oh", parece cosa de Papá Noel...). sv
#
# Será por las fechas ... ;) ok, claudico. ipg
#: find/tree.c:171
#, fuzzy, c-format
msgid "oops -- invalid expression type (%d)!"
msgstr "oh, oh -- ¡tipo de expresión inválido!"

# Creo que la traducción ideal de oops sería ¡huy! sv
# Y si no: ¿A algún español le has visto que diga "oops"?
#
# Si :) Todas las mañanas en el espejo. De todas maneras,
# `¡huy!' creo que no expresa exactamente el `indicar que
# parece que hay un problema' ... yo creo que quedaría
# mejor `oh, oh' (Rainman ... :). ipg
#
# Pero si después del huy te dicen que la expresión no es válida, está
# claro que había un problema...
# Ya, pero puestos, casi podríamos buscar una expresión común para
# los `oops'
# Pon `oh, oh', si crees que es lo apropiado.
# Lo decía más que nada por no dejarlo en inglés siendo el español
# tan rico y variado para las interjecciones.
# (Y me consta que tú sabes bastante de esto :-)
# ¡¡Carajo!! ¿yo?. Voy a dejar `oh, oh', y si a la gente le gusta
# (a mí me parece coñero), lo dejamos, y si no, ponemos `huy'. ipg
# Vale. sv
#
# Aquí también tengo pensado hacer publicidad ;-) sv
#
# Aparte de lo anterior. Si vas a dejar "oh, oh", ¿no sería mejor
# ponerlo sin tantas exclamaciones? (no me pegan)
#
# Ok. ipg
#
# Pero yo decía al revés... (como en el original).
# Lo cambio. sv
# E incluso si te parece, no ponemos ninguna exclamación en ninguno
# de los dos sitios.
# (Donde menos me pegan es en el "oh, oh", parece cosa de Papá Noel...). sv
#
# Será por las fechas ... ;) ok, claudico. ipg
#: find/tree.c:455
#, fuzzy
msgid "oops -- invalid expression type in mark_stat!"
msgstr "oh, oh -- ¡tipo de expresión inválido!"

# Creo que la traducción ideal de oops sería ¡huy! sv
# Y si no: ¿A algún español le has visto que diga "oops"?
#
# Si :) Todas las mañanas en el espejo. De todas maneras,
# `¡huy!' creo que no expresa exactamente el `indicar que
# parece que hay un problema' ... yo creo que quedaría
# mejor `oh, oh' (Rainman ... :). ipg
#
# Pero si después del huy te dicen que la expresión no es válida, está
# claro que había un problema...
# Ya, pero puestos, casi podríamos buscar una expresión común para
# los `oops'
# Pon `oh, oh', si crees que es lo apropiado.
# Lo decía más que nada por no dejarlo en inglés siendo el español
# tan rico y variado para las interjecciones.
# (Y me consta que tú sabes bastante de esto :-)
# ¡¡Carajo!! ¿yo?. Voy a dejar `oh, oh', y si a la gente le gusta
# (a mí me parece coñero), lo dejamos, y si no, ponemos `huy'. ipg
# Vale. sv
#
# Aquí también tengo pensado hacer publicidad ;-) sv
#
# Aparte de lo anterior. Si vas a dejar "oh, oh", ¿no sería mejor
# ponerlo sin tantas exclamaciones? (no me pegan)
#
# Ok. ipg
#
# Pero yo decía al revés... (como en el original).
# Lo cambio. sv
# E incluso si te parece, no ponemos ninguna exclamación en ninguno
# de los dos sitios.
# (Donde menos me pegan es en el "oh, oh", parece cosa de Papá Noel...). sv
#
# Será por las fechas ... ;) ok, claudico. ipg
#: find/tree.c:491
#, fuzzy
msgid "oops -- invalid expression type in mark_type!"
msgstr "oh, oh -- ¡tipo de expresión inválido!"

#: find/util.c:106
msgid "oops -- invalid default insertion of and!"
msgstr "oh, oh -- ¡inserción por defecto de `and' inválida!"

#  ¿Cómo traducir "path"? Me inclino por ahora por camino, pero quizá sería
#  más mejor que bueno poner directorio o algo así. IPG
#  ¡Olé! Gracias a tos los de es@li.org que me habeis dado "ruta de acceso".
#  No se qué significado tendría mi vida sin vuestra ayuda ;), snif ... :~)
#  IPG
#: find/util.c:196
#, c-format
msgid "Usage: %s [-H] [-L] [-P] [path...] [expression]\n"
msgstr "Modo de empleo: %s [-H] [-L] [-P] [ruta-de-acceso...] [expresión]\n"

#: lib/buildcmd.c:179
msgid "command too long"
msgstr "orden demasiado larga"

#: lib/buildcmd.c:241
msgid "can not fit single argument within argument list size limit"
msgstr ""
"Un argumento no cabe dentro del tamaño límite de la lista de argumentos"

#: lib/buildcmd.c:246
msgid "argument list too long"
msgstr "lista de argumentos demasiado larga"

#: lib/regextype.c:113
#, c-format
msgid "Unknown regular expression type %s; valid types are %s."
msgstr ""

#: locate/code.c:126
#, c-format
msgid ""
"Usage: %s [--version | --help]\n"
"or     %s most_common_bigrams < file-list > locate-database\n"
msgstr ""
"Modo de empleo: %s [--version | --help]\n"
"o bien  %s bigramas_más_comunes < lista-de-ficheros > base-de-datos-de-"
"locate\n"

#: locate/code.c:130 locate/frcode.c:163 locate/locate.c:1158
#: xargs/xargs.c:1226
msgid ""
"\n"
"Report bugs to <bug-findutils@gnu.org>.\n"
msgstr ""
"\n"
"Comunicar bichos a <bug-findutils@gnu.org>.\n"

#: locate/code.c:164
#, c-format
msgid "GNU findutils version %s\n"
msgstr "GNU findutils versión %s\n"

#: locate/frcode.c:161
#, c-format
msgid "Usage: %s [-0 | --null] [--version] [--help]\n"
msgstr ""

#: locate/frcode.c:201 locate/locate.c:1281
#, c-format
msgid "GNU locate version %s\n"
msgstr "GNU locate versión %s\n"

#: locate/locate.c:152
msgid "days"
msgstr "días"

#: locate/locate.c:472
#, fuzzy, c-format
msgid "locate database %s contains a filename longer than locate can handle"
msgstr ""
"atención: la ruta de acceso de la base de datos de locate `%s' comienza\n"
"por dos puntos, no es un nombre válido de base de datos"

#: locate/locate.c:567
#, c-format
msgid "locate database `%s' is corrupt or invalid"
msgstr "la base de datos de locate `%s' está corrupta o es inválida"

#: locate/locate.c:835
#, c-format
msgid "Locate database size: %s bytes\n"
msgstr ""

#: locate/locate.c:839
#, c-format
msgid "Filenames: %s "
msgstr ""

#: locate/locate.c:842
#, c-format
msgid "with a cumulative length of %s bytes"
msgstr ""

#: locate/locate.c:846
#, c-format
msgid ""
"\n"
"\tof which %s contain whitespace, "
msgstr ""

#: locate/locate.c:849
#, c-format
msgid ""
"\n"
"\t%s contain newline characters, "
msgstr ""

#: locate/locate.c:852
#, c-format
msgid ""
"\n"
"\tand %s contain characters with the high bit set.\n"
msgstr ""

#: locate/locate.c:857
#, c-format
msgid "Compression ratio %4.2f%%\n"
msgstr ""

#: locate/locate.c:905
msgid "warning: the locate database can only be read from stdin once."
msgstr ""

#: locate/locate.c:926
#, c-format
msgid "warning: database `%s' is more than %d %s old"
msgstr "atención: la base de datos `%s' tiene una antigüedad de más de %d %s"

#: locate/locate.c:1103
#, c-format
msgid "Database %s is in the %s format.\n"
msgstr ""

#: locate/locate.c:1105
msgid "old"
msgstr ""

#: locate/locate.c:1149
#, c-format
msgid ""
"Usage: %s [-d path | --database=path] [-e | -E | --[non-]existing]\n"
"      [-i | --ignore-case] [-w | --wholename] [-b | --basename] \n"
"      [--limit=N | -l N] [-S | --statistics] [-0 | --null] [-c | --count]\n"
"      [-P | -H | --nofollow] [-L | --follow] [-m | --mmap ] [ -s | --"
"stdio ]\n"
"      [-A | --all] [-p | --print] [-r | --regex ] [--regextype=TYPE]\n"
"      [--version] [--help]\n"
"      pattern...\n"
msgstr ""

#: xargs/xargs.c:300
#, c-format
msgid "Invalid escape sequence %s in input delimiter specification."
msgstr ""

#: xargs/xargs.c:318
#, c-format
msgid ""
"Invalid escape sequence %s in input delimiter specification; character "
"values must not exceed %lx."
msgstr ""

#: xargs/xargs.c:324
#, c-format
msgid ""
"Invalid escape sequence %s in input delimiter specification; character "
"values must not exceed %lo."
msgstr ""

#: xargs/xargs.c:333
#, c-format
msgid ""
"Invalid escape sequence %s in input delimiter specification; trailing "
"characters %s not recognised."
msgstr ""

#: xargs/xargs.c:378
#, c-format
msgid ""
"Invalid input delimiter specification %s: the delimiter must be either a "
"single character or an escape sequence starting with \\."
msgstr ""

#: xargs/xargs.c:394
msgid "environment is too large for exec"
msgstr "el entorno es demasiado grande para exec"

#: xargs/xargs.c:536
#, c-format
msgid "warning: value %ld for -s option is too large, using %ld instead"
msgstr ""

#: xargs/xargs.c:575
#, c-format
msgid "GNU xargs version %s\n"
msgstr "GNU xargs versión %s\n"

#: xargs/xargs.c:606
#, c-format
msgid "Cannot open input file `%s'"
msgstr ""

#: xargs/xargs.c:642
#, fuzzy, c-format
msgid "Your environment variables take up %lu bytes\n"
msgstr "Las variables de entorno ocupan %ld bytes\n"

#: xargs/xargs.c:645
#, fuzzy, c-format
msgid "POSIX lower and upper limits on argument length: %lu, %lu\n"
msgstr ""
"Límites POSIX inferior y superior sobre la longitud del argumento: %ld, %ld\n"

#: xargs/xargs.c:649
#, c-format
msgid "Maximum length of command we could actually use: %ld\n"
msgstr "Máxima longitud de orden que se podría usar realmente: %ld\n"

#: xargs/xargs.c:653
#, fuzzy, c-format
msgid "Size of command buffer we are actually using: %lu\n"
msgstr "Tamaño del búfer de órdenes que se está usando realmente: %ld\n"

#: xargs/xargs.c:775 xargs/xargs.c:856
#, c-format
msgid ""
"unmatched %s quote; by default quotes are special to xargs unless you use "
"the -0 option"
msgstr ""
"comilla %s desemparejada; por omisión las comillas son especiales para "
"xargs\n"
"a menos que utilice la opción -0"

#: xargs/xargs.c:776 xargs/xargs.c:857
msgid "double"
msgstr "doble"

#: xargs/xargs.c:776 xargs/xargs.c:857
msgid "single"
msgstr "simple"

#: xargs/xargs.c:874 xargs/xargs.c:931
msgid "argument line too long"
msgstr "línea de argumentos demasiado larga"

#: xargs/xargs.c:1101
msgid "error waiting for child process"
msgstr "error esperando al proceso hijo"

# Pregunta (no es por crear polémica): ¿"status" o "estado"? sv
#
# "Estado", aunque también existe "status". ¿Dejamos "status"? ipg
#
# No sé, si se refiere a lo que en MS-DOG se llama ERRORLEVEL,
# y al resultado numérico que devuelve el main() del proceso, la
# pregunta sería: ¿cómo se le llama a eso en español? sv
#
# Creo que podríamos dejar `status', ya que existe en castellano,
#  (Nota: Ver http://www.anaya.es/dict por ejemplo).
# y expresa un estado de actividad, siendo más preciso que `estado'
# (¡ahora, que el/la que lo confunda con el Estado Español, es pa
# matal-le! :). ipg
#
# Me quedo con la duda de cómo se llama eso en español.
# Esperemos que lo vea otro. sv
#
#: xargs/xargs.c:1117
#, c-format
msgid "%s: exited with status 255; aborting"
msgstr "%s: acabó con status 255; abortando"

#: xargs/xargs.c:1119
#, c-format
msgid "%s: stopped by signal %d"
msgstr "%s: interrumpido por la señal %d"

#: xargs/xargs.c:1121
#, c-format
msgid "%s: terminated by signal %d"
msgstr "%s: terminado por la señal %d"

#: xargs/xargs.c:1174
#, c-format
msgid "%s: invalid number for -%c option\n"
msgstr "%s: número inválido para la opción -%c\n"

# Me he tomado la libertad de poner mayor o igual que en lugar de >= ...
# queda mucho mejor. Si a alguien no le gusta, que me lo diga ;). IPG
# Me parece acertado y lo digo :-) sv
# falen ... :) ... ipg
#: xargs/xargs.c:1181
#, c-format
msgid "%s: value for -%c option should be >= %ld\n"
msgstr "%s: el valor para la opción -%c debería ser mayor o igual que %ld\n"

#: xargs/xargs.c:1195
#, c-format
msgid "%s: value for -%c option should be < %ld\n"
msgstr "%s: el valor para la opción -%c debería ser menor que %ld\n"

#: xargs/xargs.c:1215
#, fuzzy, c-format
msgid ""
"Usage: %s [-0prtx] [--interactive] [--null] [-d|--delimiter=delim]\n"
"       [-E eof-str] [-e[eof-str]]  [--eof[=eof-str]]\n"
"       [-L max-lines] [-l[max-lines]] [--max-lines[=max-lines]]\n"
"       [-I replace-str] [-i[replace-str]] [--replace[=replace-str]]\n"
"       [-n max-args] [--max-args=max-args]\n"
"       [-s max-chars] [--max-chars=max-chars]\n"
"       [-P max-procs]  [--max-procs=max-procs] [--show-limits]\n"
"       [--verbose] [--exit] [--no-run-if-empty] [--arg-file=file]\n"
"       [--version] [--help] [command [initial-arguments]]\n"
msgstr ""
"Modo de empleo: %s [-0prtx] [-e[cadena-eof]] [-i[cadena-de-reemplazo]]\n"
"       [-l[máx-líneas]] [-n máx-argumentos] [-s máx-caracteres]\n"
"       [-P máx-procesos] [--null] [--eof[=cadena-eof]]\n"
"       [--replace[=cadena-de-reemplazo]] [--max-lines[=máx-líneas]]\n"
"       [--interactive] [--max-chars=máx-caracteres] [--verbose] [--exit]\n"
"       [--max-procs=máx-procesos] [--max-args=máx-argumentos]\n"
"       [--no-run-if-empty] [--version] [--help]\n"
"       [orden [argumentos-iniciales]]\n"

#~ msgid "block size"
#~ msgstr "tamaño del bloque"

#~ msgid "argument to --limit"
#~ msgstr "argumento para --limit"

#~ msgid "Reducing arg_max (%ld) to arg_size (%ld)\n"
#~ msgstr "Se reduce arg_max (%ld) a arg_size (%ld)\n"

#~ msgid "Success"
#~ msgstr "Éxito"

#~ msgid "No match"
#~ msgstr "No hay ninguna coincidencia"

#~ msgid "Invalid regular expression"
#~ msgstr "Expresión regular inválida"

#~ msgid "Invalid collation character"
#~ msgstr "Carácter de secuencia inválido"

#~ msgid "Invalid character class name"
#~ msgstr "Nombre de clase de caracteres inválido"

#~ msgid "Trailing backslash"
#~ msgstr "Barra invertida final"

#~ msgid "Invalid back reference"
#~ msgstr "Referencia hacia atrás inválida"

#~ msgid "Unmatched [ or [^"
#~ msgstr "[ o [^ desemparejado"

#~ msgid "Unmatched ( or \\("
#~ msgstr "( o \\( desemparejado"

#~ msgid "Unmatched \\{"
#~ msgstr "\\{ desemparejada"

#~ msgid "Invalid content of \\{\\}"
#~ msgstr "Contenido de \\{\\} inválido"

#~ msgid "Invalid range end"
#~ msgstr "Final de rango inválido"

#~ msgid "Invalid preceding regular expression"
#~ msgstr "Expresión regular precedente inválida"

#~ msgid "Premature end of regular expression"
#~ msgstr "Fin prematuro de la expresión regular"

#~ msgid "Regular expression too big"
#~ msgstr "Expresión regular demasiado grande"

#~ msgid "Unmatched ) or \\)"
#~ msgstr ") o \\) desemparejado"

#~ msgid "No previous regular expression"
#~ msgstr "No hay ninguna expresión regular anterior"

#~ msgid "Predicate List:\n"
#~ msgstr "Lista Predicado:\n"

#~ msgid "Eval Tree:\n"
#~ msgstr "Árbol de Evaluación:\n"

#~ msgid "Optimized Eval Tree:\n"
#~ msgstr "Árbol de Evaluación Optimizado:\n"

# Propongo eliminar la palabra virtual. En un sistema GNU, la memoria virtual
# y la otra son la misma cosa, desde el punto de vista de las aplicaciones
# no se distinguen una de otra. Quedaría más corto, más sencillo y más bonito.
# Y además Javier Romañach (hello) está de acuerdo conmigo. sv
# Y a mí me apoya Richard Stallman };) (qui malo soy :)
# Fuera coñas ... sí, estoy de acuerdo ipg
#
# En cualquier caso, me gustaría saber por qué en GNU se empeñan en poner
# siempre "virtual". Parece como si hacerlo así estuviera el mensaje
# más orientado al usuario final [ quitando el virtual el mensaje estaría
# escrito desde el punto de vista de la aplicación (para la cual, todos
# los malloc()'s son iguales ante la ley...) ]
#
# No estoy completamente convencido de qué deberíamos hacer.
# De hecho, esto contradice mis principios (la fidelidad ante todo).
# (Creo que tendré que revisar mis principios...). sv
#
# Sí ... a fondo :) ipg
#
# FIXME: Preguntar a Richard Stallman por qué se empeña en usar la
# palabra virtual. sv
#~ msgid "virtual memory exhausted"
#~ msgstr "memoria agotada"

#~ msgid "error in %s: %s"
#~ msgstr "error en %s: %s"

#~ msgid ""
#~ "actions: -exec COMMAND ; -fprint FILE -fprint0 FILE -fprintf FILE FORMAT\n"
#~ "      -fls FILE -ok COMMAND ; -print -print0 -printf FORMAT -prune -ls -"
#~ "delete\n"
#~ "      -quit\n"
#~ msgstr ""
#~ "acciones: -exec ORDEN ; -fprint FICHERO -fprint0 FICHERO\n"
#~ "      -fprintf FICHERO FORMATO -fls FICHERO -ok ORDEN ;\n"
#~ "      -print -print0 -printf FORMATO -prune -ls -delete -quit\n"

#~ msgid "inserting %s\n"
#~ msgstr "insertando %s\n"

#~ msgid "    type: %s    %s  "
#~ msgstr "    tipo: %s    %s  "

#~ msgid "left:\n"
#~ msgstr "izquierda:\n"

#~ msgid "right:\n"
#~ msgstr "derecha:\n"

#~ msgid "Normalized Eval Tree:\n"
#~ msgstr "Árbol de Evaluación Normalizado:\n"

#~ msgid ""
#~ "Usage: %s [-d path | --database=path] [-e | --existing]\n"
#~ "      [-i | --ignore-case] [--wholepath] [--basename] [--limit=N | -l N]\n"
#~ "      [--version] [--help] pattern...\n"
#~ msgstr ""
#~ "Modo de empleo: %s [-d ruta-de-acceso | --database=ruta-de-acceso]\n"
#~ "   [-e | --existing] [-i | --ignore-case] [--wholepath] [--basename]\n"
#~ "   [--limit=N | -l N] [--version] [--help] expr-reg...\n"

#~ msgid ""
#~ "warning: locate database path `%s' contains a trailing colon, which is "
#~ "not a valid database name"
#~ msgstr ""
#~ "atención: la ruta de acceso de la base de datos de locate `%s'\n"
#~ "contiene dos puntos al final, no es un nombre válido de base de datos"

#~ msgid "%s changed during execution of %s"
#~ msgstr "%s cambió durante la ejecución de %s"

#~ msgid "%s/.. changed during execution of %s"
#~ msgstr "%s/.. cambió durante la ejecución de %s"

#~ msgid "unmatched %s quote"
#~ msgstr "comilla %s desemparejada"

#~ msgid "cannot open current directory"
#~ msgstr "no se puede abrir el directorio actual"

#~ msgid "cannot return to starting directory"
#~ msgstr "no se puede volver al directorio de partida"

#~ msgid "wait got pid %d, expected pid %d"
#~ msgstr "wait obtuvo el pid %d, y se esperaba un pid %d"

#~ msgid "%s stopped by signal %d"
#~ msgstr "%s interrumpido por la señal %d"
